import { format, parseISO, subHours } from 'date-fns';
import { ptBR } from 'date-fns/locale';

/**
 * Converts a GMT+0 date string to GMT-3 (Brazil time)
 * @param dateString ISO date string in GMT+0
 */
export const convertToGMTMinus3 = (dateString: string): Date => {
  if (!dateString) return new Date();
  
  const parsedDate = parseISO(dateString);
  return subHours(parsedDate, 3);
};

/**
 * Formats a date to Brazilian format (DD/MM/YYYY HH:mm)
 */
export const formatToBrazilianDate = (date: Date): string => {
  return format(date, 'dd/MM/yyyy HH:mm', { locale: ptBR });
};

/**
 * Converts a GMT+0 date string to Brazilian format
 */
export const formatGMT0ToBrazilianTime = (dateString: string): string => {
  if (!dateString) return '';
  
  const brazilDate = convertToGMTMinus3(dateString);
  return formatToBrazilianDate(brazilDate);
};

/**
 * Gets the date range for a specific period
 */
export const getDateRange = (period: 'today' | 'yesterday' | 'week' | 'month'): { start: Date, end: Date } => {
  const end = new Date();
  let start = new Date();
  
  switch (period) {
    case 'today':
      start.setHours(0, 0, 0, 0);
      break;
    case 'yesterday':
      start.setDate(start.getDate() - 1);
      start.setHours(0, 0, 0, 0);
      end.setDate(end.getDate() - 1);
      end.setHours(23, 59, 59, 999);
      break;
    case 'week':
      start.setDate(start.getDate() - 7);
      break;
    case 'month':
      start.setMonth(start.getMonth() - 1);
      break;
  }
  
  return { start, end };
};

/**
 * Formats a date to YYYY-MM-DD format for API queries
 */
export const formatDateForQuery = (date: Date): string => {
  return format(date, 'yyyy-MM-dd');
};

/**
 * Checks if a message contains audio content
 */
export const isAudioMessage = (content: string): boolean => {
  return content.includes('<audio>') && content.includes('</audio>');
};

/**
 * Checks if a message contains transcription content
 */
export const isTranscriptionMessage = (content: string): boolean => {
  return content.includes('*Transcription:*') || content.includes('Transcrição:');
};

/**
 * Checks if a message is an audio error message
 */
export const isAudioErrorMessage = (content: string): boolean => {
  return content.includes('Erro ao processar áudio') || 
         content.includes('Não consigo escutar seu áudio');
};

/**
 * Checks if a message contains video content
 */
export const isVideoMessage = (content: string): boolean => {
  return content.includes('<video>') && content.includes('</video>');
};

/**
 * Checks if a message contains document content
 */
export const isDocumentMessage = (content: string): boolean => {
  return content.includes('<document>') && content.includes('</document>');
};

/**
 * Extracts transcription text from audio messages
 */
export const extractTranscriptionText = (content: string): string => {
  if (isAudioMessage(content)) {
    return content.replace(/<\/?audio>/g, '').trim();
  }
  
  if (isTranscriptionMessage(content)) {
    // Extract text after *Transcription:*
    const match = content.match(/\*Transcription:\*\s*[\n\r]*_?(.*?)_?$/s);
    if (match) {
      return match[1].trim();
    }
    
    // Extract text after Transcrição:
    const ptMatch = content.match(/Transcrição:\s*[\n\r]*(.*?)$/s);
    if (ptMatch) {
      return ptMatch[1].trim();
    }
  }
  
  return content;
};

/**
 * Determines the type of media message
 */
export const getMediaMessageType = (content: string): 'audio' | 'transcription' | 'audio-error' | 'video' | 'document' | 'image' | 'text' => {
  if (isAudioErrorMessage(content)) return 'audio-error';
  if (isAudioMessage(content)) return 'audio';
  if (isTranscriptionMessage(content)) return 'transcription';
  if (isVideoMessage(content)) return 'video';
  if (isDocumentMessage(content)) return 'document';
  if (content.includes('[IMAGES]')) return 'image';
  return 'text';
};

/**
 * Groups date counts by hour for activity charts
 */
export const groupByHour = (dates: Date[]): { hour: number; count: number }[] => {
  const hourCounts: Record<number, number> = {};
  
  // Initialize all hours with 0
  for (let i = 0; i < 24; i++) {
    hourCounts[i] = 0;
  }
  
  // Count occurrences of each hour
  dates.forEach(date => {
    const hour = date.getHours();
    hourCounts[hour] = (hourCounts[hour] || 0) + 1;
  });
  
  // Convert to array format for charts
  return Object.entries(hourCounts).map(([hour, count]) => ({
    hour: parseInt(hour),
    count,
  }));
};